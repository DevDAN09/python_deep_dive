
## 2.1 내장 시퀀스 개요
### 파이썬의 시퀀스
파이썬은 시퀀스를 단일하게 처리하는 ABC의 특징을 물려받았다. 문자열, 리스트, 바이트, 시퀀스, 배열, XML 요소, 데이터베이스 결과에는 모두 반복, 슬라이싱, 정렬, 연결 등 공통된 연산을 적용할 수 있다.

이런 것들 또한 덕타이핑의 논리로 전부 시퀀스로 부를 수 있을 것 같다. 연속성을 가진 데이터 요소에 대해 일관성있는 인터페이스를 제공하고 있으니까. 파이썬이 사용자 친화적인 이유는 이런 부분들인 것 같다.

### 내장 시퀀스 개요
파이썬 표준 라이브러리는 C로 구현된 다음과 같은 시퀀스형을 제공한다.

> **컨테이너 시퀀스**
> - 서로 다른 자료형의 항목들을 담을 수 있는 `list`, `tuple`, `collections`, `deque` 형
>   
> **균일 시퀀스**
> - 단 하나의 자료형만 담을 수 있는 `str`, `bytes`, `bytearray`, `memoryview`, `array.array`형

**컨테이너 시퀀스**는 `객체에 대한 참조`를 담고 있다. 이러한 객체들은 어떠한 자료형도 될 수 있지만, **균일 시퀀스**는 객체에 대한 참조 대신 `자신의 메모리 공간에 각 항목의 값을 직접 담는다`. 따라서 균일 시퀀스가 메모리를 더 적게 사용하지만, 문자, 바이트, 숫자 등 기본적인 자료형만 저장할 수 있다.

나름 이해를 해보자면, 컨테이너 시퀀스는 java에서의 콜렉션들이 제네릭으로 콜렉션 내의 특정 타입을 받는 것과 같은 것을 이야기하는 것 같고, 균일 시퀀스는 이러한 콜렉션들은 아니지만, str 자료형 같이 시퀀스와 거의 동일한 인터페이스를 제공하는 녀석들을 의미하는 것 같다.

분류는 이 두가지만 되는 건 또 아니고, `가변성`이라는 기준에 따라 또 한번 더 분류 되어질 수 있다.

> **가변 시퀀스**
> - `list`, `bytearray`, `array.array`, `collections.deque`, `memoryview` 형
> 
> **불변 시퀀스**
> - `tuple`, `str`, `bytes` 형

가변 시퀀스와 불변 시퀀스는 또 메서드 상속도 다르단다. 물론 그렇겠지.

내장된 구체적인 시퀀스 형들이 그림에서 보는 것처럼 실제로 Sequence나 MutableSequence 추상 베이스 클래스(**a**bstract **b**ase **c**lass = **ABC**)를 상속하는 것은 아니지만, 추상 베이스 클래스를 이용하면 실제 시퀀스 형에서 어느 기능을 제공할지 예측하는 데 도움이 된다고 한다.

## 2.2 지능형 리스트와 제너레이터 표현식
지능형 리스트(리스트형의 경우)나 제너레이터 표현식(그 외 시퀀스의 경우)을 사용하면 시퀀스를 간단히 생성할 수 있다. 이런 구문을 사용하고 있지 않다면, 가독성이 좋고 때로는 실행 속도도 빠른 코드를 만들 기회를 허비하고 있는 것이라고 한다.

### 2.2.1 지능형 리스트와 가독성
```python
symbols = '$!@#!@$'
codes = []
for symbol in symbols:
	codes.append(ord(symbol))
>> codes
```

```python
symbols = '$!@#!@$'
codes = [ord(symbol) for symbol in symbols]
>> codes
```

어떤게 더 보기 쉬울까?
대체로 2번 코드가 더 좋다고 생각할 수 있다. 의도를 명확하게 보여주기 때문이다.
물론 이를 남용하면 정말 이해하기 어려운 코드를 만들 수도 있다. 같은 이유로 코드도 짧게 해야한다. 구문이 두 줄 이상 넘어가는 경우에는 코드를 분할하거나 차라리 for문으로 빼는게 더 낫다.

**경우에 맞게 상식적으로 판단하자.**

> **💡 책에서 이해가 안 되었던 말들**
> 
> - ***60p. 생성된 리스트를 사용하지 않을 거라면 지능형 리스트 구문을 사용하지 말아야한다.***
>   -> 너무 당연한 소리를 하는게 아닌가..?ㅋㅋㅋㅋ 이 말의 본질을 캐치하지 못 한건지 생각을 해봐야겠네요.

### 번외. 지능형 리스트는 더 이상 메모리를 누수하지 않는다.
옛날 옛적 파이썬 2.x 시절에는 지능형 리스트 안의 for 문에서 할당한 변수는 주변 범위에서 다른 변수와 함께 설정되므로 때로 비참한 결과가 일어나기도 했다고 한다.

```python
x = 'my precious'
dummy = [x for x in 'abc']
>> x
'c'
```

여기서 볼 수 있는 것 처럼 x에 처음 설정 되었던 값이 사라졌다. 파이썬 3에서는 이런 문제가 발생하지 않는다고 한다. 함수처럼 고유한 지역 범위를 가지기 때문에 표현식 내의 동일 변수는 지역 변수로써 구분된다. 따라서 원래의 값을 잃지 않는 것이다. 이걸 보니 파이썬 2는 정말 하자 있는 언어임을 알 수 있었다.

### 2.2.2 지능형 리스트와 map()/filter() 비교
map()과 filter() 함수를 이용해서 수행할 수 있는 작업은 기능적으로 문제가 있는 파이썬 람다를 억지로 끼워 넣지 않고도 지능형 리스트를 이요해서 모두 구현할 수 있다.

```python
symbols = '!@#@!'
beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]

---

symbols = '!@#@!'
beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
```

책의 저자는 map/filter를 조합한 방법이 지능형 리스트보다 빠르다고 생각했다는데 알렉스 마르텔리 아저씨가 지적해줘서 아니라는 걸 알았다고 한다. 우리도 일단 지금까지 나온 예제들에 한해서는 일단 그렇다고 알자.

### 2.2.3 데카르트 곱
지능형 리스트는 두 개 이상의 반복 가능한 자료형의 데카르트 곱을 나타내는 일련의 리스트를 만들 수 있다.
데카르트 곱 안에 들어 있는 각 항목은 입력으로 받은 반복 가능한 데이터의 각 요소에서 만들어진 튜플로 구선된다.

![[Pasted image 20240117193806.png]]

예를 들어 두 가지 색생과 세 가지 크기의 티셔츠 리스트를 만드는 경우를 생각해보자. 지능형 리스트를 이용해서 생성하는 방법을 통해서 결국 여섯 개의 항목이 만들어진다.

```python
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
tshirts
[('black', 'S'), ('black', 'M')...] # 총 6개 !
```

이걸 응용하면 포커 카드 52장 한 줄에 뽑아내는게 가능하다.

```python
# 52장 생성됨
self._cards = [Card(rank, suit) for suit in self.suits
								for rank in self.ranks]
```

### 2.2.4 제너레이터 표현식
```python
import array

symbols = '!@#$!()'

# 튜플 뽑아내기
tuple(ord(symbol) for symbol in symbols)
# 배열 뽑아내기
array.array('I', (ord(symbol) for symbol in symbols))
```

나는 제너레이터 표현식이 뭔지 잘 몰랐는데, 이런 식으로 원하는 객체를 생성하면서 필요한 데이터를 생성자 부분에 표현식을 넣는 식으로 쓰는게 제너레이터 표현식인 것 같다. 그래서 이름이 제너레이터구나

이 방법이 메모리를 덜 먹는다고 한다. 왜냐하면 생성자에 전달할 리스트를 통째로 만들지 않고 **반복자 프로토콜**이라는 놈을 이용해서 항목을 하나씩 생성하기 때문이다.

## 2.3 튜플은 단순한 불변 리스트가 아니다.
입문서에서 튜플이 단순한 불변 리스트로 설명하는 경우가 있다. 나 또한 그렇게 배웠고.
그러나 그런 설명만으로는 부족하다. 튜플은 불변 리스트로 사용할 수 있지만 필드명이 없는 레코드로써도 쓸 수 있다. 우선 레코드를 사용하는 경우를 알아보자.

### 2.3.1 레코드로서의 튜플
튜플은 레코드를 담고 있다. 튜플의 각 항목은 레코드의 필드 하나를 의미하며 항목의 위치가 의미를 결정한다.
튜플을 필드의 집합으로 사용하는 경우에는 항목 수가 고정되어 있고 항목의 순서가 중요하다.
이제 왜 불변인지 알겠다. 왜? 데이터베이스 레코드를 생각해보자. 필드들이 가변적으로 막 변하게 되어있나? 적어도 런타임에서는 아니다.

아래 코드는 실제 레코드로 튜플을 사용하는 예시이다.

```python
lax_coordinates = (33.9425, -118.408056)
city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)
traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567')]
```

주의 깊게 생각해야하는 점은 레코드로서 작동하는 경우 항목의 위치가 항목의 의미(필드)를 나타내므로 튜플을 정렬하면 레코드로서의 정보가 파괴된다는 점이다. 잘 생각하자.

### 2.3.2 튜플 언패킹
위에서 city, year, pop, chg, area 변수의 경우 튜플 객체를 할당했다. 각 변수에는 튜플의 필드가 순서대로 할당된 상황이다. 이를 언패킹이라고 한다.

튜플 언패킹은 병렬 할당을 할 때 가장 눈에 띈다. 병렬 할당은 다음 코드에서 보는 것처럼 반복형 데이터를 변수로 구성된 튜플에 할당하는 것을 말한다.

```python
lax_coordinates = (33.9425, -118.408056)
latitude, longitude = lax_corrdinates # 튜플 언패킹
```

얘를 잘 사용한다면 temp 없이도 두 변수의 값을 서로 교환할 수 있다.

```python
b, a = a, b
```

참 파이써닉하다.

다음과 같이 `*` 를 붙여서 튜플을 언패킹할 수도 있다.

``` python
divmod(20, 8)
>> (2, 4)

t = (20, 8)
divmod(*t)
>> (2, 4)
```

우리가 코테에서 흔히 사용하는 `a, b = input().split()`도 일종이라고 할 수 있겠다.

더미 변수를 플레이스홀더로 사용해 관심없는 부분은 언패킹할 때 무시할 수도 있다.
다음 코드를 보자.
```python
...
_, filename = os.path.split('blabla')
```

### 꿀팁. 초과 항목을 잡기 위해 `*` 사용하기
```python
a, b, *rest = range(5)
>> a, b, rest
(0, 1, [2, 3, 4])

---

a, b, *rest = range(3)
>> a, b, rest
(0, 1, [2])

---

a, b, *rest = range(2)
>> a, b, rest
(0, 1, [])

---

a, *body, c, d = range(5)
a, body, c, d
>> (0, [1, 2], 3, 4)

...
```

이딴식으로 초과된 인수를 가져올 수도 있으니 참고. 파이썬의 고전적인 기능이다.
어떤 식으로든 변수의 개수에 맞게끔 가져올 수 있다.

### 내포된 튜플 언패킹
(a, b, (c, d))처럼 다른 튜플을 내포할 수 있다. 파이썬은 표현식이 내포된 구조체에 일치하면 제대로 처리한다.

![[Pasted image 20240117203807.png]]

튜플은 아주 편리하지만, 레코드로 사용하기엔 부족한 점이 있다. 필드에 이름을 붙이고 싶을 때가 있으니까.
이럴 때 namedtuple()을 사용하는 것이다.

### 2.3.4 명명된 튜플(namedtuple)
collections.namedtuple() 함수는 필드명과 클래스명을 추가한 튜플의 서브클래스를 생성하는 팩토리 함수로서, 디버깅할 때 유용하다.

```python
Card = collections.namedtuple('Card', ['rank', 'suit'])
```

이런 식으로 쓴다.

![[Pasted image 20240117204103.png]]

요런식으로 쓸 수 있으니 참고.
근데 나는 아직도 이렇게 쓸 바에 그냥 클래스 하나 파고 빌더 패턴으로, 혹은 코틀린 스타일의 생성자 세팅 방식으로 데이터 레코드를 세팅해주는게 더 가시성이 좋아보인다고 생각한다. 이런게 파이썬의 매력이겠지. 사랑해보려고 노력해볼게요.

### 2.3.5 불변 리스트로서의 튜플
튜플을 불변 리스트로 사용할 때, 튜플과 리스트가 얼마나 비슷한지 알고 있으면 도움이 된다.
튜플은 `__reversed__()` 메서드를 제외하고 리스트가 제공하는 메서드를 모두모두 지원한다고 한다.
착각하지 말거는 reversed(tuple) 이런 방식은 `__reversed__()`를 이용하지 않는다는 점!

## 2.4 슬라이싱
아까 나왔던 언급했던 시퀀스 이야기를 꺼내본다. 시퀀스는 모두 슬라이싱을 지원한다.
잘 쓰면 엄청 강력하다고 책에서 이야기하는데, 어디 얼마나 대단한지 좀 보자.

### 2.4.1 슬라이스와 범위 지정시에 마지막 항목이 포함되지 않는 이유
슬라이스와 범위 지정시에 마지막 항목을 포함하지 않는 관례는 인덱스 번호가 0번부터 시작하는 파이썬, C 등의 언어에서 잘 작동한다. 이 관례 덕분에 다음과 같은 장점이 있다.

1. 세 개의 항목을 생성하는 `range(3)`나 `my_list[:3]`처럼 중단점만 이용해서 슬라이스나 범위를 지정할 때 길이를 계산하기 쉽다.
2. 시작점과 중단점을 모두 지정할 때도 길이를 계산하기 쉽다. 단지 중단점에서 시작점을 빼면 된다.
3. 다음 예제에서 보는 것처럼, x 인덱스를 기준으로 겹침 없이 시퀀스를 분할하기 쉽다. 단지 `my_list[:x]`와 `my_list[x:]`로 지정하면 된다.

### 2.4.2 슬라이스 객체
`s[a:b:c]`는 c 보폭만큼 항목을 건너뛰게 만든다. 보폭이 음수인 경우에는 거꾸로 거슬러 올라가 항목을 반환한다.

`deck[12::13]`도 가능하다. 13번의 보폭만큼 건너뛰는 것이니, 한 칸씩 뒤의 인덱스를 참조하게 될 것이다.

이 `a:b:c` 표기법은 인덱스 연산을 수행하는 [] 안에서만 사용할 수 있으며, slice(a, b, c) 객체를 생성한다. 10.4.1절 '슬라이싱 작동 방식'에서 설명할 내용이 있는데, `seq[start:stop:step]` 표현식을 평가하기 위해 파이썬은 `seq.__getitem__(slice(start, stop, step))`을 호출한다.

시퀀스형을 직접 구현하지 않더라도 슬라이스 객체를 알아두면 도움이 된단다. 스프레드시트에서 셀 범위에 이름을 붙이는 것처럼 슬라이스 객체는 슬라이스에 이름을 붙일 수 있게 해주기 때문이다.

코드에서 슬라이스를 하드코딩하는 대신 각 슬라이스에 이름을 붙일 수 있는데, 아래의 코드를 통해 이게 for 루프 가독성을 얼마나 올릴 수 있는지를 보자.

```python
SKU = slice(0, 6)
DESCRIPTION = slice(6, 40)
UNIT_PRICE = slice(40, 52)
QUANTITY = slice(52, 55)
ITEM_TOTAL = slice(55, None)
line_items = invoice.split('\n')[2:]

for item in line_items:
	print(item[UNIT_PRICE], item[DESCRIPTION])
```

### 2.4.3 다차원 슬라이싱과 생략 기호
[] 연산자는 콤마로 구분해서 여러 개의 인덱스나 슬라이스를 가질 수 있다. [] 연산자를 처리하는 `__getitem__()`과 `__setitem__()` 특수 메서드는 `a[i, j]` 에 들어 있는 인덱스들을 튜플로 받는다. 
즉, `a[i, j]`를 평가하기 위해 파이썬은 `a.__getitem__((i, j))`을 호출한다. 파이썬에 내장된 시퀀스형은 1차원이므로 단 하나의 인덱스나 슬라이스만 지원하고 튜플을 지원하지 않는다.

세 개의 마침표(...)로 표현된 생략 기호는 파이썬 파서에 의해 하나의 토큰으로 인식된다. 이 기호는 Ellipsis 객체의 별명으로서 하나의 ellipsis 클래스의 객체다. 생략 기호 객체는 f(a, ..., z)처럼 함수의 인수나, `a[i:...]`처럼 슬라이스의 한 부분으로 전달할 수 있다. 

조금 tmi인 거 같긴 한데 Numpy는 다차원 배열을 슬라이싱할 때 생략기호(...)를 사용한다고 한다.예를 들어 x가 4차원 배열이라면 `x[i, ...]`는 `x[i, :, :, :,]`와 동일하다. 

현재까지 파이썬 표준 라이브러리에서 Eliipsis나 다차원 인덱스 및 슬라이스를 사용하는 사례는 없다고 하는데, 책이 언제 나왔는지를 조금 생각해봐야할 듯. 이 구문법은 사실상 사용자 정의 자료형이나 NumPy 등의 확장 패키지를 지원하기 위해 존재하는 것으로 보인다.

### 2.4.4 슬라이스에 할당하기
슬라이스는 시퀀스에서 정보를 추출할 뿐만이 아니라 가변 시퀀스의 값을 변경할 때도 사용할 수 있다. 할당문의 왼쪽에 슬라이스 표기법을 사용하거나 del 문의 대상 객체로 지정함으로서 가변 시퀀스를 연결하거나, 잘라 내거나, 값을 변경할 수 있다. 다음 코드를 통해 이 표기법의 강력함을 보자.

![[Pasted image 20240118013916.png]]
![[Pasted image 20240118013948.png]]

다소 어메이징하다고 할 수 있겠다.
