
## 데이터 모델
데이터 모델은 일종의 프레임워크이다. 파이썬을 설명하는 것이기도 하며, 시퀀스, 반복자, 함수, 클래스, 컨텍스트 관리자 등 언어 자체의 구성단위에 대한 인터페이스를 공식적으로 정의하는 것이다.

## 특별 메서드
파이썬의 모든 자료형은 객체이다. 인터프리터가 이러한 객체들의 기본적인 연산을 수행하는 것에 있어서 어떠한 인터페이스를 사용하는데, 이것이 바로 특별 메서드(혹은 매직 메서드)이다.

특별 메서드는 `__getitem__()`과 같이 앞 뒤에 이중 언더바를 갖고 있는 외형을 가졌다.
종종 특별한 구문에 의해 호출되는데, 예를 들어 `obj[key]`형태의 구문은 `__getitem__()` 특별 메서드가 지원하는 형식이다.

이 특별 메서드는 어떠한 인터페이스라고 이야기할 수 있다고 했다. 당연히 사용자가 만드는 객체에서도 오버라이드를 할 수 있다. 다음 코드에서 확인할 수 있다.

## 특별 메서드 활용 예: 파이썬 카드 한 벌
```python
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
	ranks = [str(n) for n in range(2, 11)] + list('JQKA')
	suits = 'spades diamonds clubs hearts'.split()

	def __init__(self):
		self._cards = [Card(rank, suit) for suit in self.suits
										for rank in self.ranks]

	def __len__(self):
		return len(self._cards)

	def __getitem__(self, position):
		return self.cards[position]
```

이 코드에서는 `collections.namedtuple()`을 이용해서 개별 카드를 나타내는 클래스를 구현한다. 

파이썬 2.6부터는 `namedtuple`을 이용해서 데이터베이스의 레코드처럼 메서드를 가지지 않는 일련의 속성으로 구성된 클래스를 만들 수 있다. 이 클래스를 이용하면 다음 콘솔 세션에서 보는 것처럼 카드 한 장을 멋지게 표현할 수 있다.

```python
>>> beer_card = Card('7', 'diamonds')
>>> bear_card
Card(rank='7', suit='diamonds')
```

그러나 이 코드의 핵심은 `FrenchDeck` 클래스다. 현재 코드는 단순하지만, 꽤 많은 기능을 구현하는데 하나를 예로 들면 파이썬 컬렉션과 마찬가지로 `len()`함수를 통해 자신이 갖고 있는 카드의 수를 반환할 수 있다거나 하는 식이다.

`__getitem__()`이 구현 되어있기 때문에, 이를 사용하는 다른 함수에서도 편하게 이용가능한, 일종의 일관된 확장성을 갖게할 수 있다.

예를 들어 random의 choice 함수를 쓰는 모습을 보면
```python
from random import choice
print(choice(deck))

-> Card(rank='3', suit='hearts')
```
와 같은 결과를 얻을 수 있다.

`__getitem__()`를 통한 확장성은 무궁무진한 편으로, 원소를 가져다 쓰는 메서드라면 다 사용이 가능하다. `reversed(), in` 등등...

`__contains__()`매직 메서드가 구현이 안 되어있으면 in은 하나하나씩 탐색 즉 선형탐색을 한다는 데, 사용자 정의 자료형에서 이 매직 메서드를 구현하면 탐색 성능을 향상시킬수도 있겠다.

## 특별 메서드의 사용?
특별 메서드(매직 메서드)에 대해 먼저 알아둬야할 점은, 이 메서드는 개발자가 아니라 인터프리터가 호출하기 위한 것이라는 점이다.

특별 메서드를 호출해야할 경우에는 len(), iter(), str() 등의 관련 내장 함수를 호출하는 것이 좋다. 이들 내장 함수가 해당 특별 메서드를 호출한다. 하지만 내장 데이터형의 경우 특별 메서드를 호출하지 않는 경우도 있으며 이 경우 메서드 호출보다 빠르다.

## 문자열 표현
`__repr__()` 특별 메서드는 객체를 문자열로 표현하기 위해 repr() 내장 메서드에 의해 호출된다.
이게 구현이 안 되어있으면 우리가 흔히 접하는 `<Vecter obect at 0x10e....>` 이런 출력을 만나게 되는 것이다.

`__str__()`도 있긴 한데 두 특별 메서드 중 하나만 구현해야 한다면 `__repr__()`를 구현하도록 하자. str은 파이썬 인터프리터가 기본적으로 뒤져보는 내용이고 이게 없을 때의 대책으로 `__repr__()` 메서드를 호출하기 때문이란다.

print의 여행 지도를 그려보면 다음과 같다.
```python
if __str__() 이 구현 되어있나?:
	__str__() 호출해서 반환 값 출력
elif __repr__()이 구현 되어있나?:
	__repr__() 호출해서 반환 값 출력
else:
	그냥 클래스 이름이랑 기타 등등 출력해..
```
이런 느낌으로 진행된다.

## 산술 연산자
사용자 정의 자료형에서 `+, *`는 각각 `__add__()`와 `__mul__()`을 통해 구현될 수 있다. 일종의 연산자 오버로딩이라고 보면 될 것 같다.

## 사용자 정의형의 불리언 값
`if, while, and, or, not`에 대한 피연산자로서 불리언형이 필요한 곳에는 어떠한 객체라도 사용할 수 있다. 참된 값인지, 거짓된 값인지 판단하기 위해 파이썬은 `bool()`을 적용하며 이 함수는 항상 True, False를 반환한다.

`__bool__()`이나 `__len__()`을 구현하지 않은 경우 기본적으로 사용자 정의 클래스의 객체는 참된 값이라고 간주된다.

bool()은 `__bool__()`을 호출한 결과를 이용한다. 이게 0을 뱉으면 False를, 그렇지 않으면 True를 반환한다.

## 왜 len()은 메서드가 아닐까?
`실용성이 순수성에 우선한다`라는 일종의 원칙이 이유다.

len(x)은 x가 내장형의 객체일 때 아주 빨리 실행된다.
CPython의 내장 객체에 대해서는 메서드를 호출하지 않고 단지 C 언어 구조체 필드를 읽어올 뿐이다.

좀 더 정리해서 len()은 abs()와 마찬가지로 파이썬 데이터 모델에서 특별한 대우를 받으므로 메서드라고 부르지 않는다. 그러나 `__len__()` 특별 메서드 덕분에 우리가 정의한 객체에서 len 메서드를 직접 정의할 수 있다. 

내장형 객체의 효율성과 언어의 일관성 간의 타협정을 어느정도 맞춘 것이라고 할 수 있겠다.

## 가지치기: 중위 연산자의 동작 방식
> 조금은 제목을 바꿀필요도 있어보이네용 ㅋㅋ

산술 연산자 파트를 진행하면서 의문이 하나 생겼다.

> add의 동작방식을 보면 나와 다른 객체를 더해서 돌려주는 것이다. 
> 왼쪽에 있던 오른쪽에 있던 모두 add가 돌아가면 문제가 생길 것 같은데?

사용자 지정형에 관해서는 주도적으로 add할 수 없는 숫자를 연산에 끼워넣어 실험해보기로 했다.  

실험결과 `Beomsu + 2`는 잘 작동했으나 `2 + Beomsu`는 작동하지 않았다. 대충은 예상했지만 add의 내용은 사용자 지정 객체의 뒤에 연산자와 연산 대상이 있을 때 동작하는 식이었다.

근데 위처럼 우리의 삶에선 더하기 연산 등의 교환법칙이 전혀 이상하지 않다. 위처럼 쓰는게 전혀 어색한게 아니라는 말이다.

`파이써닉`에 대한 내 나름에 해석에 의하면 사용자가 아래 구현을 잘 몰라도 적절히 사용할 수 있는 직관성, 일관성을 잘 갖춰야한다.

위의 상황은 전혀 그렇지 못하다고 생각을 했고, 파이썬 측에서 이런 대책을 준비하지 않았을리 없다고 생각을 해서 열심히 찾아봤다. 그렇게 찾아본 결과는 다음과 같다.

### 중위 연산자의 동작
> 출처: https://elvanov.com/1265
```python
# 직관성을 위해 일일히 나열한 코드입니다.
a + b
->
if a에 add가 있나?:
	result = a.__add__(b)

	if result가 NotImplemented 인가?:
		if b에 __radd__가 있는가?:
			result = b.__radd__(a)
		
			if result가 NotImplemented 인가?:
				throw TypeError
		
			return result

	return result
	
elif b에 __radd__가 있는가?:
	result = b.__radd__(a)

	if result가 NotImplemented 인가?:
		throw TypeError

	return result
```

더하기 같은 경우 앞의 녀석과 연산을 할 수 있는 `__radd__()`가 있다. `__add__()`와 동시에 발생하는 것은 아니고 우선순위를 갖는다.

`__add__()`가 있으면 add, 없으면 `__radd__()`를 찾아보는 식이다. 
곱하기 연산 같은 경우도 `__rmul__`이 있으니 참고가 가능할 것같다.

```python
class Beomsu:

def __init__(self, age) -> None:

	self.age = age

def __add__(self, num) -> int:

	self.age += num

  

	return self.age

def __radd__(self, num) -> int:

self.age += num

  

return self.age

  

beomsu = Beomsu(20)

  

print(beomsu + 2)

print(2 + beomsu)
```

![[Pasted image 20240104145632.png]]

잘 된다!

++ 어...ㅋㅋ 근데 beomsu + beomsu도 된다?? add 명세에 의하면 num아
이유 찾았다 age랑 더하는 건데 age가 숫자니까 되는 거네