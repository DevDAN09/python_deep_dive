# chapter2

## 2.4 슬라이싱

- list, tuple, str 모든 시퀀스 형은 슬라이싱 연산을 지원함

### 2.4.1 슬라이싱 범위 지정시 마지막 항목이 포함되지 않는 이유

- 중단점을 사용하여 슬라이스나 범위를 지정할때 길이를 계산하기 쉬움
    - range(3) : 0 1 2 → 길이 3
    - range(1,3) : 1 2 → 3-1 = 2
- x 인덱스 기준으로 겹침 없이 시퀀스를 분할하기 쉬움
    - list[:x] , list[x:]

### 2.4.2 슬라이스 객체

s[a:b:c] 

c : 보폭

seq.__getitem__(slice(start, stop, step))

### 2.4.3 다차원 슬라이싱 과 생략 기호

```markdown
[ ] 연산자를 처리하는 __getitem__() 과 __setitem__() 
특수 메서드는 a[i, j]는 인덱스들을 튜플 형태로 받음
-> a.__getitem__((i,j)) 형태로 호출
```

```markdown
... 는 파이썬에서 하나의 토큰으로 해석됨
ellipsis의 하나의 객체

x[i, ...] 는 x[i, :, :, :,] 동일함
```

### 2.4.4 슬라이스에 할당하기

- 슬라이싱을 통해 리스트의 인덱싱 값들을 할당 및 해제 할 수 있음

## 2.5 시퀀스에 덧셈과 곱셈 연산자 사용하기

```python
l = [1,2,3]
l * 5
[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
```

### 2.5.1 리스트의 리스트 만들기

- 리스트의 리스트를 만들때는 지능형 리스트를 만드는 것이 좋다

```python
board = [['_'] * 3 for i in range(3)]

// 잘못된 코드
weired_board = [['_'] * 3] * 3]
```

## 2.6 시퀀스의 복합할당

- 일반적으로 **가변 시퀀스**는 __iadd__() 메서드를 구현하여 += 연산자가 기존 객체의 내용을 변경하게 만드는 것이 좋다.
- **불변 시퀀스**는 객체의 변경이 존재하지 않으므로 불가능함을 알아야한다

### 2.6.1 += 복합 할당 쿼즈

```python
t = (1,2, [30, 40])
t[2] += [50, 60]
```

1. t는 (1, 2, [30, 40, 50, 60])
2. 튜플 객체는 항목 할당을 지원하지 않는다 는 메세지와 함께 TypeError가 발생한다
3. 둘다 맞다
4. 둘다 틀리다

- 가변 항목을 튜플에 넣는것은 좋은 생각이 아니다
- 복합 할당은 원자적 연산이 아니다
- 파이썬 바이트코드를 살펴보는 것은 그리 어렵지 않으며, 내부에서 어떤 일이 발생하고 있는지 살펴보는데 도움이된다

## 2.7 list.sort()와 sorted() 내장함수

- list.sort()는 메서드의 사본을 만들지 않고 리스트의내부를 변경하여 정렬한다.
- 매서드는 타겟을 변경하고 세로운 리스트를 생성하지 않았음을 알려주기위해 None을 반환
- 파이썬에서 None을 반환하는 것은 객체가 새롭게 생성되지 않았음을 표현하는 관례이다

- sorted() 함수는 새로운 리스트를 생성하여 반환하는 기능
- 불변시퀀스 제너레이터 포함한 반복 가능한 객체를 인수로 받을 수 있다

선택적인 2개의 인자

1. reverse
2. key 
    1. key = str.lower
    2. key = len

## 2.8 정렬된 시퀀스를 bisect로 관리하기

bisect 모듈은 bisect() 와 insort() 함수를 제공한다. bisect()은 이진 검색 알고리즘을 이용하여 시퀀스를 검색하고, insort()는 정렬된 시퀀스 안에 항목을 삽입진행함

### 2.8.1 bisect()로 검색하기

```python
bisect(haystack, needle) 
```

- 정렬된 시퀀스인 haystack안에서 오름차순 정렬상태를 유지한채로 needle 을 추가할 수 있는 위치를 찾아낸다

```python
import bisect

a = [1, 2, 4, 5]
x = 3

# x를 a에 삽입할 위치 찾기
pos = bisect.bisect_left(a, x)
a.insert(pos, x)  # 리스트 a는 이제 [1, 2, 3, 4, 5]가 됩니다.

# x를 삽입할 오른쪽 위치 찾기
pos_right = bisect.bisect_right(a, x)
# pos_right는 x를 삽입할 때, x와 같은 값이 있으면 그 오른쪽 위치를 나타냅니다.
```

### 2.8.2 bisect.insort()로 삽입하기

- 시퀀스를 정렬 후에 정렬상태를 유지하는 것이 좋음
- insort(seq, item) 은 seq 자료형을 유지 한체로 item을 삽입하는 연산이다

```python
import bisect
import random

SIZE = 7 

random.seed(1729)

my_list = []
for i range(SIZE):
	new_item = random.randrange(SIZE*2)
	bisect.insort(my_list, new_item)
	print('%2d ->' % new_item, my_list)
```

- insort 함수와 마찬가지로 lo 와 hi 인수를 받아 시퀀스 안에 검색할 범위를 제한함
- 삽입 위치를 검색하기 위해서 insort_left() 함수도 존재함

## 2.9 리스트가 답이 아닐때

리스트 이외에도 배열, FIFO 나 LIFO를 수행하는 덱의 자료구조가 존재한다

### 2.9.1 배열

- 숫자를 다루는 자료구조를 사용할 떄 효과적임(decimal)
- 가변시퀀스가 지원하는 연산 pop(), insert(), extend()를 지원
- 파일을 저장하고 읽어오는 frombytes()와 tofile() 메서드도 추가로 제공
- C의 배열과 같이 가벼움

### 2.9.2 메모리 뷰

메모리뷰는 넘파이 배열 구조체를 일반화를 진행한 것이며, 다양한 파이썬의 패키지의 데이터 구조체들을 복사하지 않고 메모리를 공유할 수 있게 해줌 데이터 셋이 커지는 코드에서 메모리를 공유하여 메모리 공간을 효과적으로 사용할 수 있는 중요한 기법

메모리뷰에 대한 추가 설명

```python
# 바이트 배열 생성
byte_array = bytearray('ABCDEF', 'utf-8')

# memoryview 객체 생성
mem_view = memoryview(byte_array)

# memoryview를 사용하여 바이트 배열의 일부 변경
mem_view[1:4] = b'123'

# 변경된 바이트 배열 출력
print(byte_array)  # bytearray(b'A123EF')

# memoryview의 일부 슬라이스 접근
print(mem_view[1:4])  # <memory at 0x...>

# 슬라이스된 부분의 실제 데이터 출력
print(bytes(mem_view[1:4]))  # b'123'

# memoryview 해제
mem_view.release()
```

이 예시에서는 먼저 'ABCDEF' 문자열로 바이트 배열 **`byte_array`**를 생성함. 그 후, 이 바이트 배열에 대한 **`memoryview`** 객체 **`mem_view`**를 생성합니다. **`memoryview`**를 사용하여 바이트 배열의 일부를 '123'으로 변경**`memoryview`** 객체를 통해 바이트 배열의 일부에 접근하고, 이를 **`bytes`** 객체로 변환하여 실제 데이터를 출력. 마지막으로, **`mem_view.release()`** 메소드를 호출하여 **`memoryview`** 객체가 참조하는 리소스를 명시적으로 해제 가능

### 2.9.4 덱 및 기타큐

append()와 pop() 메서드를 사용하면 리스트를 스택이나 큐로서 사용할 수 있음 하지만 해당 연산을 통해 리스트의 아이템들이 순차적으로 이동하여야하므로 컴퓨터의 연산 부담은 커질 수 밖에 없다

덱을 사용하여 양방향으로 삽입과 삭제를 진행할수 있다. 이는 한마디라 스레드 안전한 양방향 큐이다. 덱을 사용하여 제한된 항목을 정하여 제한된 항목을 초과한 item이 왼쪽으로 입력이 되면 제한된 아이템 중 하나를 반대 방향으로 pop을 진행하는 형태로 사용이 가능하다